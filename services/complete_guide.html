<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Complete System Integration Guide</title>
    <style>
        @page {
            margin: 0.75in;
        }
        @media print {
            body { font-size: 10pt; }
            h1 { page-break-before: always; margin-top: 0; }
            h1:first-of-type { page-break-before: auto; }
            h2 { page-break-before: always; margin-top: 0; }
            h2:first-of-type { page-break-before: auto; }
            pre, table { page-break-inside: avoid; }
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.7;
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            color: #2c3e50;
        }
        .cover {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin: -40px -20px 60px -20px;
            padding: 100px 20px;
            page-break-after: always;
        }
        .cover h1 {
            font-size: 3.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .cover .subtitle {
            font-size: 1.8em;
            margin: 20px 0;
        }
        .cover .description {
            font-size: 1.2em;
            margin: 10px 0;
            max-width: 800px;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 4px solid #3498db;
            padding-bottom: 15px;
            margin-top: 60px;
            font-size: 2.5em;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #95a5a6;
            padding-bottom: 12px;
            margin-top: 50px;
            font-size: 2em;
        }
        h3 {
            color: #2980b9;
            margin-top: 35px;
            font-size: 1.5em;
        }
        h4 {
            color: #16a085;
            margin-top: 25px;
            font-size: 1.2em;
        }
        code {
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: Monaco, 'Courier New', monospace;
            font-size: 0.9em;
            color: #c7254e;
        }
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 20px 0;
        }
        pre code {
            background: transparent;
            border: none;
            padding: 0;
            color: #f8f8f2;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 25px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 14px;
            text-align: left;
        }
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        li {
            margin: 10px 0;
        }
        .footer {
            margin-top: 80px;
            padding-top: 30px;
            border-top: 2px solid #dee2e6;
            text-align: center;
            color: #6c757d;
        }
        .highlight-box {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }
    </style>
</head>
<body>
    <div class="cover">
        <h1>Complete System Integration Guide</h1>
        <div class="subtitle">How All 5 Services Work Together</div>
        <div class="description">
            A comprehensive guide showing how the Cost Estimator System
            components integrate to provide complete healthcare cost estimates
        </div>
        <div class="version">
            <p>Technical Documentation v1.0</p>
            <p>October 2025</p>
            <p>Five Services Working as One System</p>
        </div>
    </div>
    <div class="content">
        <p><h1>Complete System Integration Guide</h1></p>
<p><h2>How All Services Work Together in the Cost Estimator System</h2></p>
<p>---</p>
<p><h2>Table of Contents</h2></p>
<p><li>[Executive Overview](#executive-overview)</li>
<li>[The Five Core Services](#the-five-core-services)</li>
<li>[System Architecture](#system-architecture)</li>
<li>[Service Dependencies and Relationships](#service-dependencies-and-relationships)</li>
<li>[Complete Data Flow](#complete-data-flow)</li>
<li>[Step-by-Step Integration Flow](#step-by-step-integration-flow)</li>
<li>[Real-World Example: Complete Journey](#real-world-example-complete-journey)</li>
<li>[Service Interaction Patterns](#service-interaction-patterns)</li>
<li>[Error Handling Across Services](#error-handling-across-services)</li>
<li>[Performance: Parallel Execution](#performance-parallel-execution)</li>
<li>[Detailed Service Roles](#detailed-service-roles)</li>
<li>[Integration Points](#integration-points)</li>
<li>[Complete Flow Diagrams](#complete-flow-diagrams)</li>
<li>[Summary and Key Insights](#summary-and-key-insights)</li></p>
<p>---</p>
<p><h2>1. Executive Overview</h2></p>
<p><h3>The Big Picture</h3></p>
<p>The <strong>Cost Estimator System</strong> is composed of <strong>5 interconnected services</strong> that work together to provide healthcare cost estimates:</p>
<p><pre><code class="language-">┌────────────────────────────────────────────────────────────┐
│                  USER REQUEST                              │
│  "How much will I pay for an office visit with Dr. Smith?"│
└──────────────────┬─────────────────────────────────────────┘
                   ↓
┌────────────────────────────────────────────────────────────┐
│           COST ESTIMATION SERVICE                          │
│           (Main Orchestrator)                              │
│                                                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │   BENEFIT    │  │ ACCUMULATOR  │  │     RATE     │   │
│  │   SERVICE    │  │   SERVICE    │  │  REPOSITORY  │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
│         ↓                 ↓                  ↓            │
│  ┌─────────────────────────────────────────────────────┐  │
│  │    BENEFIT-ACCUMULATOR MATCHER SERVICE              │  │
│  │    (Combines benefit rules with accumulator data)   │  │
│  └─────────────────────────────────────────────────────┘  │
│                           ↓                                │
│  ┌─────────────────────────────────────────────────────┐  │
│  │         CALCULATION SERVICE                         │  │
│  │         (Processes through 10 handler chain)        │  │
│  └─────────────────────────────────────────────────────┘  │
└──────────────────┬─────────────────────────────────────────┘
                   ↓
┌────────────────────────────────────────────────────────────┐
│                  RESPONSE                                  │
│  "You will pay: $25 (copay)"                              │
│  "Insurance pays: $975"                                   │
│  "Remaining deductible: $600"                             │
└────────────────────────────────────────────────────────────┘</code></pre></p>
<p><h3>What Each Service Does</h3></p>
<p><li><strong>Cost Estimation Service</strong> - Main orchestrator that coordinates everything</li>
<li><strong>Benefit Service</strong> - Fetches coverage rules from external API</li>
<li><strong>Accumulator Service</strong> - Fetches current spend amounts from external API</li>
<li><strong>Benefit-Accumulator Matcher</strong> - Combines benefits with accumulators</li>
<li><strong>Calculation Service</strong> - Calculates final member cost through handler chain</li></p>
<p>---</p>
<p><h2>2. The Five Core Services</h2></p>
<p><h3>Service 1: Cost Estimation Service (Orchestrator)</h3></p>
<p><strong>File:</strong> <code>cost_estimation_service_impl.py</code></p>
<p><strong>Role:</strong> Main coordinator - the conductor of the orchestra</p>
<p><strong>What It Does:</strong>
<li>Entry point for cost estimation requests</li>
<li>Coordinates all other services</li>
<li>Fetches data in parallel (async)</li>
<li>Processes multiple providers in parallel (threads)</li>
<li>Builds final response</li></p>
<p><strong>Key Methods:</strong>
<pre><code class="language-python">async def estimate_cost(request, headers) -> CostEstimatorResponse</code></pre></p>
<p><strong>Think of it as:</strong> The project manager who delegates tasks to specialists</p>
<p>---</p>
<p><h3>Service 2: Benefit Service (External API Client)</h3></p>
<p><strong>File:</strong> <code>benefit_service_impl.py</code></p>
<p><strong>Role:</strong> Fetches benefit coverage rules</p>
<p><strong>What It Does:</strong>
<li>Communicates with external Benefit API</li>
<li>Retrieves coverage rules (copay, coinsurance, deductible rules)</li>
<li>Handles OAuth 2.0 authentication</li>
<li>Manages token refresh</li>
<li>Returns benefit data or error</li></p>
<p><strong>Key Methods:</strong>
<pre><code class="language-python">async def get_benefit(benefit_request, raise_exception) -> BenefitApiResponse</code></pre></p>
<p><strong>Returns:</strong>
<pre><code class="language-">Benefit Rules:
  - Copay: $25
  - Coinsurance: 20%
  - Deductible applies? Yes/No
  - Network: In-Network
  - Tier: 1</code></pre></p>
<p><strong>Think of it as:</strong> The insurance policy reader</p>
<p>---</p>
<p><h3>Service 3: Accumulator Service (External API Client)</h3></p>
<p><strong>File:</strong> <code>accumulator_service_impl.py</code></p>
<p><strong>Role:</strong> Fetches current accumulator amounts</p>
<p><strong>What It Does:</strong>
<li>Communicates with external Accumulator API</li>
<li>Retrieves current spend amounts</li>
<li>Returns deductible remaining, OOP max remaining, benefit limits</li>
<li>Handles OAuth 2.0 authentication</li>
<li>Supports both JSON and XML responses</li></p>
<p><strong>Key Methods:</strong>
<pre><code class="language-python">async def get_accumulator(request, headers) -> AccumulatorResponse</code></pre></p>
<p><strong>Returns:</strong>
<pre><code class="language-">Current Amounts:
  - Deductible remaining: $600
  - OOP Max remaining: $3000
  - Visit limit remaining: 8 visits</code></pre></p>
<p><strong>Think of it as:</strong> The accountant tracking what you've spent so far</p>
<p>---</p>
<p><h3>Service 4: Benefit-Accumulator Matcher (Data Combiner)</h3></p>
<p><strong>File:</strong> <code>benefit_accumulator_matcher_service_impl.py</code></p>
<p><strong>Role:</strong> Bridges benefits and accumulators</p>
<p><strong>What It Does:</strong>
<li>Filters benefits by provider (network, tier, designation)</li>
<li>Matches filtered benefits with appropriate accumulators</li>
<li>Creates SelectedBenefit objects with complete data</li>
<li>Ensures benefit rules are paired with current amounts</li></p>
<p><strong>Key Methods:</strong>
<pre><code class="language-python">def get_selected_benefits(...) -> List[SelectedBenefit]</code></pre></p>
<p><strong>Input:</strong>
<pre><code class="language-">Benefits: "Copay $25, Deductible applies"
Accumulators: "Deductible remaining: $600"</code></pre></p>
<p><strong>Output:</strong>
<pre><code class="language-">SelectedBenefit:
  Copay: $25
  matchedAccumulators: [
    Deductible: $600 remaining
    OOP Max: $3000 remaining
  ]</code></pre></p>
<p><strong>Think of it as:</strong> The data integration specialist who matches rules with reality</p>
<p>---</p>
<p><h3>Service 5: Calculation Service (Business Logic Engine)</h3></p>
<p><strong>File:</strong> <code>calculation_service_impl.py</code></p>
<p><strong>Role:</strong> Calculates final member cost</p>
<p><strong>What It Does:</strong>
<li>Creates chain of 10 calculation handlers</li>
<li>Processes benefits through handler chain</li>
<li>Each handler applies specific business rule</li>
<li>Supports branching for complex scenarios</li>
<li>Returns highest member pay (worst case)</li></p>
<p><strong>Key Methods:</strong>
<pre><code class="language-python">def find_highest_member_pay(service_amount, benefits) -> InsuranceContext</code></pre></p>
<p><strong>Handler Chain:</strong>
<pre><code class="language-">ServiceCoverage → BenefitLimitation → OOPMax → 
Deductible → CostShareCopay → [Result]</code></pre></p>
<p><strong>Output:</strong>
<pre><code class="language-">InsuranceContext:
  member_pays: $25
  amount_copay: $25
  amount_coinsurance: $0</code></pre></p>
<p><strong>Think of it as:</strong> The calculator that applies all the rules</p>
<p>---</p>
<p><h2>3. System Architecture</h2></p>
<p><h3>High-Level Architecture</h3></p>
<p><pre><code class="language-">┌─────────────────────────────────────────────────────────────┐
│                    HTTP API LAYER                           │
│                  (FastAPI Router)                           │
└────────────────────────┬────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│              COST ESTIMATION SERVICE                        │
│              (Main Orchestrator)                            │
│                                                             │
│  ┌───────────────────────────────────────────────────┐     │
│  │  PHASE 1: PARALLEL DATA FETCHING (Async)         │     │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐       │     │
│  │  │ Benefit  │  │Accumulator│  │   Rate   │       │     │
│  │  │ Service  │  │  Service  │  │Repository│       │     │
│  │  └────┬─────┘  └────┬──────┘  └────┬─────┘       │     │
│  │       ↓             ↓              ↓              │     │
│  │  External API  External API   Database           │     │
│  └───────────────────────────────────────────────────┘     │
│                         ↓                                   │
│  ┌───────────────────────────────────────────────────┐     │
│  │  PHASE 2: DATA INTEGRATION                        │     │
│  │  ┌─────────────────────────────────────────┐      │     │
│  │  │  Benefit-Accumulator Matcher Service    │      │     │
│  │  │  (Combines and filters data)            │      │     │
│  │  └─────────────────────────────────────────┘      │     │
│  └───────────────────────────────────────────────────┘     │
│                         ↓                                   │
│  ┌───────────────────────────────────────────────────┐     │
│  │  PHASE 3: BUSINESS LOGIC EXECUTION                │     │
│  │  ┌─────────────────────────────────────────┐      │     │
│  │  │     Calculation Service                 │      │     │
│  │  │     (10 Handler Chain)                  │      │     │
│  │  └─────────────────────────────────────────┘      │     │
│  └───────────────────────────────────────────────────┘     │
└────────────────────────┬────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│                    RESPONSE TO CLIENT                       │
└─────────────────────────────────────────────────────────────┘</code></pre></p>
<p><h3>Layered Architecture</h3></p>
<p><pre><code class="language-">┌─────────────────────────────────────────────────────┐
│ LAYER 1: API/PRESENTATION                          │
│ - FastAPI Router                                   │
│ - Request validation                               │
│ - Response serialization                           │
└──────────────────┬──────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────────┐
│ LAYER 2: ORCHESTRATION                             │
│ - Cost Estimation Service                          │
│ - Coordinates all services                         │
│ - Parallel execution management                    │
└──────────────────┬──────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────────┐
│ LAYER 3: DATA SERVICES                             │
│ - Benefit Service (External API)                   │
│ - Accumulator Service (External API)               │
│ - Repository (Database)                            │
└──────────────────┬──────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────────┐
│ LAYER 4: BUSINESS LOGIC                            │
│ - Benefit-Accumulator Matcher                      │
│ - Calculation Service (Handler Chain)              │
└──────────────────┬──────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────────┐
│ LAYER 5: DATA ACCESS                               │
│ - Google Cloud Spanner                             │
│ - External APIs                                    │
└─────────────────────────────────────────────────────┘</code></pre></p>
<p>---</p>
<p><h2>4. Service Dependencies and Relationships</h2></p>
<p><h3>Dependency Diagram</h3></p>
<p><pre><code class="language-">┌────────────────────────────────────────────────┐
│      Cost Estimation Service                   │
│      (Depends on all 4 below)                  │
└───┬────────┬────────┬────────┬─────────────────┘
    │        │        │        │
    ↓        ↓        ↓        ↓
┌────────┐ ┌────────┐ ┌────────┐ ┌────────────────┐
│Benefit │ │Accumul-│ │Reposit-│ │Benefit-        │
│Service │ │ator    │ │ory     │ │Accumulator     │
│        │ │Service │ │        │ │Matcher         │
└────────┘ └────────┘ └────────┘ └───┬────────────┘
                                      │
                                      ↓
                              ┌────────────────┐
                              │Calculation     │
                              │Service         │
                              └────────────────┘</code></pre></p>
<p><h3>Detailed Dependencies</h3></p>
<p><strong>Cost Estimation Service depends on:</strong>
<pre><code class="language-">1. Repository
   - get_rate()
   - get_cached_pcp_specialty_codes()</p>
<p><li>Benefit Service</li>
   - get_benefit()</p>
<p><li>Accumulator Service</li>
   - get_accumulator()</p>
<p><li>Matcher Service</li>
   - get_selected_benefits()</p>
<p><li>Calculation Service</li>
   - find_highest_member_pay()</code></pre></p>
<p><strong>Benefit-Accumulator Matcher depends on:</strong>
<pre><code class="language-">- None (pure business logic)
<li>Takes data as input, processes, returns result</code></pre></li></p>
<p><strong>Calculation Service depends on:</strong>
<pre><code class="language-">- None (pure business logic)
<li>10 handler classes</li>
<li>InsuranceContext data structure</code></pre></li></p>
<p><strong>Benefit Service depends on:</strong>
<pre><code class="language-">- Token Service (OAuth authentication)
<li>Session Manager (Token storage)</code></pre></li></p>
<p><strong>Accumulator Service depends on:</strong>
<pre><code class="language-">- Token Service (OAuth authentication)
<li>Session Manager (Token storage)</code></pre></li></p>
<p><h3>Dependency Injection</h3></p>
<p><pre><code class="language-python">class CostEstimationServiceImpl:
    def __init__(
        self,
        repository=None,
        matcher_service=None,
        benefit_service=None,
        accumulator_service=None,
        calculation_service=None,
    ):
        self.repository = repository or CostEstimatorRepositoryImpl()
        self.matcher_service = matcher_service or BenefitAccumulatorMatcherServiceImpl()
        self.benefit_service = benefit_service or BenefitServiceImpl()
        self.accumulator_service = accumulator_service or AccumulatorServiceImpl()
        self.calculation_service = calculation_service or CalculationServiceImpl()</code></pre></p>
<p><strong>Benefits:</strong>
<li>Loose coupling</li>
<li>Easy testing (inject mocks)</li>
<li>Flexibility (swap implementations)</li></p>
<p>---</p>
<p><h2>5. Complete Data Flow</h2></p>
<p><h3>Data Flow Overview</h3></p>
<p><pre><code class="language-">1. REQUEST
   CostEstimatorRequest
   ↓</p>
<p><li>FETCH PHASE (Parallel - Async)</li>
   ├─ Benefit Service → BenefitApiResponse
   ├─ Accumulator Service → AccumulatorResponse
   └─ Repository → NegotiatedRate
   ↓</p>
<p><li>ORGANIZATION PHASE</li>
   ├─ rate_dict: {provider_hash → rate}
   ├─ benefit_response_dict: {provider_hash → benefit}
   └─ accumulator_response (single for member)
   ↓</p>
<p><li>MATCHING PHASE (Per Provider)</li>
   Matcher Service
   ├─ Input: Benefits + Accumulators + Provider
   └─ Output: SelectedBenefit (with matched accumulators)
   ↓</p>
<p><li>CALCULATION PHASE (Per Provider)</li>
   Calculation Service
   ├─ Input: Service Amount + SelectedBenefits
   ├─ Process: Handler Chain (10 handlers)
   └─ Output: InsuranceContext (member_pays)
   ↓</p>
<p><li>RESPONSE BUILDING</li>
   CostEstimatorResponse
   └─ costEstimate: [info for each provider]
   ↓</p>
<p><li>RETURN</li>
   JSON Response to Client</code></pre></p>
<p><h3>Data Transformations</h3></p>
<p><pre><code class="language-">┌─────────────────────────────────────────────────┐
│ INPUT: CostEstimatorRequest                     │
│ {membershipId, service, providerInfo[]}         │
└──────────────────┬──────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────┐
│ TRANSFORM 1: To Service Inputs                  │
│ - BenefitRequest[]                              │
│ - RateCriteria[]                                │
└──────────────────┬──────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────┐
│ FETCH: Raw Data                                 │
│ - BenefitApiResponse[]                          │
│ - AccumulatorResponse                           │
│ - NegotiatedRate[]                              │
└──────────────────┬──────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────┐
│ TRANSFORM 2: To Dictionaries                    │
│ - benefit_response_dict                         │
│ - rate_dict                                     │
└──────────────────┬──────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────┐
│ TRANSFORM 3: Matching                           │
│ Benefit + Accumulator → SelectedBenefit         │
│ (with matchedAccumulators)                      │
└──────────────────┬──────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────┐
│ TRANSFORM 4: Calculation                        │
│ SelectedBenefit → InsuranceContext              │
│ (with member_pays)                              │
└──────────────────┬──────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────┐
│ TRANSFORM 5: Response Building                  │
│ InsuranceContext → CostEstimateResponseInfo     │
└──────────────────┬──────────────────────────────┘
                   ↓
┌─────────────────────────────────────────────────┐
│ OUTPUT: CostEstimatorResponse                   │
│ {service, costEstimate[]}                       │
└─────────────────────────────────────────────────┘</code></pre></p>
<p>---</p>
<p><h2>6. Step-by-Step Integration Flow</h2></p>
<p><h3>Complete Flow (Numbered Steps)</h3></p>
<p><strong>STEP 1: Request Arrives</strong>
<pre><code class="language-">API Router receives HTTP POST
↓
Validates CostEstimatorRequest
↓
Calls: cost_estimation_service.estimate_cost(request, headers)</code></pre></p>
<p><strong>STEP 2: Map Request to Service Inputs</strong>
<pre><code class="language-">Cost Estimation Service:
  - Maps request → BenefitRequest[] (one per provider)
  - Maps request → RateCriteria[] (one per provider)
  - Counts providers for later splitting</code></pre></p>
<p><strong>STEP 3: Parallel Data Fetching (Async)</strong>
<pre><code class="language-">Cost Estimation Service calls asyncio.gather():
  
  For each provider:
    ├─ Repository.get_rate(criteria)
    └─ Benefit Service.get_benefit(request)
  
  For member (once):
    └─ Accumulator Service.get_accumulator(request, headers)</p>
<p>All execute simultaneously!
Result: [rate1, rate2, ..., benefit1, benefit2, ..., accumulator]</code></pre></p>
<p><strong>STEP 3a: Benefit Service Details</strong>
<pre><code class="language-">Benefit Service.get_benefit():
  1. Get authentication token
  2. Build HTTP headers
  3. Send POST to external Benefit API
  4. Handle response:
     - 200: Parse BenefitApiResponse
     - 401: Refresh token, retry
     - 400: Check member not found
     - 500: Retry with exponential backoff
  5. Return BenefitApiResponse or Exception</code></pre></p>
<p><strong>STEP 3b: Accumulator Service Details</strong>
<pre><code class="language-">Accumulator Service.get_accumulator():
  1. Get authentication token
  2. Build HTTP headers
  3. Send GET to external Accumulator API
  4. Handle response:
     - 200: Parse AccumulatorResponse
     - 401: Refresh token, retry
     - 400/500: Handle errors
  5. Return AccumulatorResponse</code></pre></p>
<p><strong>STEP 3c: Repository Details</strong>
<pre><code class="language-">Repository.get_rate():
  1. Build SQL query with rate criteria
  2. Query Google Cloud Spanner
  3. Parse results
  4. Apply payment method hierarchy
  5. Return NegotiatedRate</code></pre></p>
<p><strong>STEP 4: Organize Data</strong>
<pre><code class="language-">Cost Estimation Service:
  Split gathered_result:
    - Extract rates → rate_dict {provider_hash → rate}
    - Extract benefits → benefit_response_dict {provider_hash → benefit}
    - Extract accumulator (last item)
  
  Get PCP specialty codes from cache</code></pre></p>
<p><strong>STEP 5: Parallel Provider Processing (Threads)</strong>
<pre><code class="language-">Cost Estimation Service with ThreadPoolExecutor:
  
  For each provider (in parallel):
    Call: build_ce_info_list_from_providers(provider)
    
    Inside this method:
      ↓
      STEP 5a: Lookup Data
      ↓
      STEP 5b: Match
      ↓
      STEP 5c: Calculate
      ↓
      STEP 5d: Build Response Info</code></pre></p>
<p><strong>STEP 5a: Lookup Provider Data</strong>
<pre><code class="language-">build_ce_info_list_from_providers():
  - benefit = benefit_response_dict[provider.hash()]
  - rate = rate_dict[provider.hash()]
  
  Check if benefit fetch failed:
    YES → Return error info
    NO → Continue</code></pre></p>
<p><strong>STEP 5b: Match Benefits with Accumulators</strong>
<pre><code class="language-">Matcher Service.get_selected_benefits():
  1. Determine provider designation (PCP or Specialist)
  2. Get provider tier
  3. Loop through all benefits:
     - Filter by network (In vs Out)
     - Filter by designation (PCP match)
     - Filter by tier (1, 2, 3)
  4. For each matching benefit:
     - Get relatedAccumulators from benefit
     - Find matching accumulators from member data
     - Match by: code, level, network
     - Create SelectedBenefit with matchedAccumulators
  5. Return List[SelectedBenefit]</code></pre></p>
<p><strong>STEP 5c: Calculate Member Pay</strong>
<pre><code class="language-">Calculation Service.find_highest_member_pay():
  1. For each SelectedBenefit:
     - Create InsuranceContext
     - Populate from benefit and accumulators
  2. Process each context through handler chain (parallel):
     ServiceCoverageHandler
     ↓
     BenefitLimitationHandler
     ↓
     OOPMaxHandler
     ↓
     DeductibleHandler
     ↓
     CostShareCoPayHandler
     ↓
     Result: context.member_pays calculated
  3. Find context with highest member_pays
  4. Return InsuranceContext</code></pre></p>
<p><strong>STEP 5d: Build Response Info</strong>
<pre><code class="language-">CostEstimatorResponse.build_cost_estimate_response_info():
  - Takes: provider, selected_benefits, context, rate
  - Builds: CostEstimateResponseInfo
    - providerInfo
    - coverage (from benefit)
    - cost (from rate)
    - healthClaimLine (from context)
    - accumulators (from matchedAccumulators)
  - Handles errors (rate not found, benefits not matching)
  - Returns: CostEstimateResponseInfo or Error</code></pre></p>
<p><strong>STEP 6: Collect Results</strong>
<pre><code class="language-">Cost Estimation Service:
  - Collects all provider info objects
  - Filters out None results
  - Has list of CostEstimateResponseInfo</code></pre></p>
<p><strong>STEP 7: Build Final Response</strong>
<pre><code class="language-">CostEstimatorResponse.build_cost_estimator_response_from_info_objects():
  - Takes: request, info_list
  - Builds: CostEstimatorResponse
    - service (from request)
    - costEstimate (list of provider infos)
  - Returns: CostEstimatorResponse</code></pre></p>
<p><strong>STEP 8: Return to Client</strong>
<pre><code class="language-">Cost Estimation Service returns CostEstimatorResponse
↓
API Router serializes to JSON
↓
HTTP Response sent to client</code></pre></p>
<p>---</p>
<p><h2>7. Real-World Example: Complete Journey</h2></p>
<p><h3>Scenario</h3></p>
<p><strong>User Question:</strong>
"How much will I pay for an office visit (CPT 99214) with Dr. Smith?"</p>
<p><h3>Input</h3></p>
<p><pre><code class="language-json">{
  "membershipId": "5~186103331+10+7+20240101+793854+8A+829",
  "benefitProductType": "Medical",
  "service": {
    "code": "99214",
    "type": "CPT4",
    "placeOfService": {"code": "11"}
  },
  "providerInfo": [{
    "providerIdentificationNumber": "0004000317",
    "speciality": {"code": "08"},
    "providerNetworkParticipation": {"providerTier": "1"},
    "providerNetworks": {"networkID": "NETWORK1"}
  }]
}</code></pre></p>
<p><h3>Step-by-Step Processing</h3></p>
<p><strong>STEP 1-2: Request Processing (5ms)</strong>
<pre><code class="language-">- API validates request ✓
<li>Cost Estimation Service starts</li>
<li>Maps to 1 BenefitRequest, 1 RateCriteria</code></pre></li></p>
<p><strong>STEP 3: Parallel Fetch (200ms)</strong>
<pre><code class="language-">Thread 1: Repository.get_rate()
  Query Spanner: "SELECT rate WHERE provider=..."
  → Result: NegotiatedRate(rate=1000.00, isRateFound=True)
  Time: 100ms</p>
<p>Thread 2: Benefit Service.get_benefit()
  Token: Get from cache ✓
  POST to https://api.benefits.com/retrieve
  Request: {membershipId, service, provider}
  Response: BenefitApiResponse(copay=25.00, networkCategory="InNetwork")
  Time: 200ms</p>
<p>Thread 3: Accumulator Service.get_accumulator()
  Token: Get from cache ✓
  GET https://api.accumulators.com/read
  Request: {membershipId}
  Response: AccumulatorResponse([
    Deductible-Individual: 600.00 remaining,
    OOP Max-Individual: 3000.00 remaining
  ])
  Time: 150ms</p>
<p>All complete at 200ms (longest operation)</code></pre></p>
<p><strong>STEP 4: Organization (5ms)</strong>
<pre><code class="language-">rate_dict = {
  "75001-08-NETWORK1-0004000317": NegotiatedRate(1000.00)
}</p>
<p>benefit_response_dict = {
  "75001-08-NETWORK1-0004000317": BenefitApiResponse(...)
}</p>
<p>accumulator_response = AccumulatorResponse(...)</code></pre></p>
<p><strong>STEP 5a: Lookup (1ms)</strong>
<pre><code class="language-">provider_hash = "75001-08-NETWORK1-0004000317"
benefit = benefit_response_dict[provider_hash]
rate = rate_dict[provider_hash]</p>
<p>benefit = BenefitApiResponse(copay=25.00, networkCategory="InNetwork")
rate = NegotiatedRate(1000.00)</code></pre></p>
<p><strong>STEP 5b: Matching (10ms)</strong>
<pre><code class="language-">Matcher Service.get_selected_benefits():</p>
<p>Provider specialty "08" in PCP codes? YES
→ provider_designation = "PCP"</p>
<p>Provider tier: "1"</p>
<p>Loop through benefits:
  Benefit 1: networkCategory="InNetwork", tier="1", designation="PCP"
    - Network match? YES (InNetwork == InNetwork) ✓
    - Designation match? YES (PCP == PCP) ✓
    - Tier match? YES (1 == 1) ✓
    → MATCH! Continue to accumulator matching</p>
<p>  Benefit 1 has relatedAccumulators:
    - Deductible-Individual
    - OOP Max-Individual</p>
<p>  Member has accumulators:
    - Deductible-Individual: 600.00 remaining → MATCH ✓
    - OOP Max-Individual: 3000.00 remaining → MATCH ✓</p>
<p>Create SelectedBenefit:
  costShareCopay: 25.00
  matchedAccumulators: [
    Deductible-Individual (600.00),
    OOP Max-Individual (3000.00)
  ]</p>
<p>Return: [SelectedBenefit]</code></pre></p>
<p><strong>STEP 5c: Calculation (30ms)</strong>
<pre><code class="language-">Calculation Service.find_highest_member_pay():</p>
<p>Create InsuranceContext:
  service_amount: 1000.00
  cost_share_copay: 25.00
  deductible_individual_calculated: 600.00
  oopmax_individual_calculated: 3000.00</p>
<p>Process through handler chain:</p>
<p>  Handler 1: ServiceCoverageHandler
    is_service_covered? YES
    → Continue</p>
<p>  Handler 2: BenefitLimitationHandler
    has_benefit_limitation? NO
    → Continue</p>
<p>  Handler 3: OOPMaxHandler
    min_oopmax = 3000.00 (> 0)
    → Continue (not met)</p>
<p>  Handler 4: DeductibleHandler
    deductible_remaining = 600.00
    is_deductible_before_copay? NO
    has copay? YES
    has coinsurance? NO
    → Continue (copay applies, not deductible)</p>
<p>  Handler 5: CostShareCoPayHandler
    cost_share_copay = 25.00
    member_pays = min(25.00, 1000.00) = 25.00
    calculation_complete = TRUE
    → STOP</p>
<p>Result: InsuranceContext(member_pays=25.00, amount_copay=25.00)</code></pre></p>
<p><strong>STEP 5d: Build Response Info (5ms)</strong>
<pre><code class="language-">CostEstimateResponseInfo:
  providerInfo: {...}
  coverage: {
    isServiceCovered: "Y",
    costShareCopay: 25.00,
    costShareCoinsurance: 0
  }
  cost: {
    inNetworkCosts: 1000.00,
    inNetworkCostsType: "AMOUNT"
  }
  healthClaimLine: {
    amountCopay: 25.00,
    amountCoinsurance: 0.00,
    amountResponsibility: 25.00,
    percentResponsibility: 2.5,
    amountpayable: 975.00
  }
  accumulators: [
    {
      accumulator: {code: "Deductible", calculatedValue: 600.00},
      accumulatorCalculation: {remainingValue: 600.00, appliedValue: 0.00}
    },
    {
      accumulator: {code: "OOP Max", calculatedValue: 3000.00},
      accumulatorCalculation: {remainingValue: 3000.00, appliedValue: 0.00}
    }
  ]</code></pre></p>
<p><strong>STEP 6-8: Final Response (5ms)</strong>
<pre><code class="language-">Build CostEstimatorResponse:
  service: {...}
  costEstimate: [CostEstimateResponseInfo]</p>
<p>Serialize to JSON</p>
<p>Return to client</code></pre></p>
<p><h3>Timeline</h3></p>
<p><pre><code class="language-">0ms:    Request arrives
5ms:    Request mapped
10ms:   Start parallel fetch
210ms:  All data fetched
215ms:  Data organized
216ms:  Start matching
226ms:  Matching complete
227ms:  Start calculation
257ms:  Calculation complete
262ms:  Response info built
267ms:  Final response built
272ms:  Return to client</p>
<p>Total: 272ms</code></pre></p>
<p><h3>Output</h3></p>
<p><pre><code class="language-json">{
  "service": {
    "code": "99214",
    "type": "CPT4"
  },
  "costEstimate": [{
    "providerInfo": {...},
    "coverage": {
      "isServiceCovered": "Y",
      "costShareCopay": 25.00
    },
    "cost": {
      "inNetworkCosts": 1000.00
    },
    "healthClaimLine": {
      "amountCopay": 25.00,
      "amountResponsibility": 25.00,
      "amountpayable": 975.00
    },
    "accumulators": [
      {
        "accumulator": {
          "code": "Deductible",
          "level": "Individual",
          "calculatedValue": 600.00
        },
        "accumulatorCalculation": {
          "remainingValue": 600.00,
          "appliedValue": 0.00
        }
      }
    ]
  }]
}</code></pre></p>
<p><strong>User sees:</strong>
<li>You will pay: <strong>$25</strong> (copay)</li>
<li>Insurance pays: <strong>$975</strong></li>
<li>Deductible remaining: <strong>$600</strong></li></p>
<p>---</p>
<p><h2>8. Service Interaction Patterns</h2></p>
<p><h3>Pattern 1: Orchestration (Cost Estimation Service)</h3></p>
<p><pre><code class="language-">Cost Estimation Service acts as orchestrator:
  - Calls multiple services
  - Waits for responses
  - Aggregates results
  - Makes decisions based on results</code></pre></p>
<p><strong>Example:</strong>
<pre><code class="language-python"><h1>Orchestrator decides what to do based on results</h1>
if benefit_fetch_failed:
    return error_response
elif no_matching_benefits:
    return error_response
else:
    continue_processing()</code></pre></p>
<p><h3>Pattern 2: Client-Server (External APIs)</h3></p>
<p><pre><code class="language-">Service → External API
  Request ↓
  Response ↑</code></pre></p>
<p><strong>Benefit Service and Accumulator Service use this pattern</strong></p>
<p><h3>Pattern 3: Data Transformation Pipeline</h3></p>
<p><pre><code class="language-">Raw Data → Transform → Enrich → Calculate → Format → Return</code></pre></p>
<p><strong>Example Flow:</strong>
<pre><code class="language-">BenefitApiResponse
  ↓ (Transform)
SelectedBenefit
  ↓ (Calculate)
InsuranceContext
  ↓ (Format)
CostEstimateResponseInfo</code></pre></p>
<p><h3>Pattern 4: Chain of Responsibility (Calculation Service)</h3></p>
<p><pre><code class="language-">Request → Handler1 → Handler2 → Handler3 → ... → Result</code></pre></p>
<p><strong>Each handler decides:</strong>
<li>Process and continue</li>
<li>Process and stop</li>
<li>Branch to different handler</li></p>
<p><h3>Pattern 5: Parallel Execution</h3></p>
<p><strong>Two Levels:</strong></p>
<p><strong>Level 1: Async (I/O-bound)</strong>
<pre><code class="language-python">await asyncio.gather(
    fetch_benefit(),
    fetch_accumulator(),
    fetch_rate()
)</code></pre></p>
<p><strong>Level 2: Threads (CPU-bound)</strong>
<pre><code class="language-python">with ThreadPoolExecutor():
    executor.map(process_provider, providers)</code></pre></p>
<p>---</p>
<p><h2>9. Error Handling Across Services</h2></p>
<p><h3>Error Propagation</h3></p>
<p><pre><code class="language-">┌─────────────────────────────────────────────┐
│ Benefit Service                             │
│ Error: Member not found (400)               │
└──────────────────┬──────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│ Cost Estimation Service                     │
│ Catches: BenefitsNotFoundException          │
│ Stores in: benefit_response_dict            │
└──────────────────┬──────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│ build_ce_info_list_from_providers()        │
│ Checks type: is BenefitsNotFoundException? │
│ YES → Create error response info           │
└──────────────────┬──────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│ Final Response                              │
│ CostEstimateResponseInfoError               │
│ {exception: {...}}                          │
└─────────────────────────────────────────────┘</code></pre></p>
<p><h3>Error Handling at Each Layer</h3></p>
<p><strong>Layer 1: External Services</strong>
<pre><code class="language-">Benefit Service:
  - Catches HTTP errors
  - Converts to domain exceptions
  - Returns BenefitsNotFoundException</p>
<p>Accumulator Service:
  - Catches HTTP errors
  - Converts to domain exceptions
  - Returns AccumulatorNotFoundException</code></pre></p>
<p><strong>Layer 2: Cost Estimation Service</strong>
<pre><code class="language-">- Catches service exceptions
<li>Stores in dictionaries (not crash)</li>
<li>Single provider: Raises exception</li>
<li>Multiple providers: Returns error info</code></pre></li></p>
<p><strong>Layer 3: Matcher/Calculation</strong>
<pre><code class="language-">Matcher:
  - Catches exceptions
  - Logs error
  - Returns empty list</p>
<p>Calculation:
  - Wraps in try/catch
  - Returns unmodified context on error
  - Prevents one benefit from crashing all</code></pre></p>
<p><h3>Graceful Degradation</h3></p>
<p><pre><code class="language-">Scenario: 3 providers, 1 fails</p>
<p>Provider 1: Success → CostEstimateResponseInfo
Provider 2: Benefit not found → CostEstimateResponseInfoError
Provider 3: Success → CostEstimateResponseInfo</p>
<p>Result: Response with 3 items (2 success + 1 error)
User still gets useful information!</code></pre></p>
<p>---</p>
<p><h2>10. Performance: Parallel Execution</h2></p>
<p><h3>Two-Level Parallelism</h3></p>
<p><strong>Level 1: Async (Data Fetching)</strong>
<pre><code class="language-">Sequential Time:
  Rate:        100ms
  Benefit:     200ms
  Accumulator: 150ms
  Total:       450ms</p>
<p>Parallel Time:
  All at once: 200ms (longest operation)
  
Speedup: 2.25x</code></pre></p>
<p><strong>Level 2: Threads (Provider Processing)</strong>
<pre><code class="language-">Sequential Time:
  Provider 1: 50ms
  Provider 2: 50ms
  Provider 3: 50ms
  Total:      150ms</p>
<p>Parallel Time:
  All at once: 50ms</p>
<p>Speedup: 3x</code></pre></p>
<p><strong>Combined Performance</strong></p>
<p><pre><code class="language-">Full Sequential Flow:
  Fetch (sequential): 450ms
  Process (sequential): 150ms
  Total: 600ms</p>
<p>Full Parallel Flow:
  Fetch (parallel): 200ms
  Process (parallel): 50ms
  Total: 250ms</p>
<p>Overall Speedup: 2.4x</code></pre></p>
<p><h3>Performance Breakdown by Service</h3></p>
<p><pre><code class="language-">Cost Estimation Service: 5ms (orchestration)
  ├─ Benefit Service: 200ms (external API)
  ├─ Accumulator Service: 150ms (external API)
  ├─ Repository: 100ms (database query)
  ├─ Matcher Service: 10ms (business logic)
  └─ Calculation Service: 30ms (handler chain)</p>
<p>With parallelization:
  External calls: 200ms (all parallel)
  Business logic: 45ms (sequential per provider)
  Total: ~250ms</code></pre></p>
<p>---</p>
<p><h2>11. Detailed Service Roles</h2></p>
<p><h3>Cost Estimation Service: The Conductor</h3></p>
<p><strong>Responsibilities:</strong>
<li>Receive and validate request</li>
<li>Coordinate all service calls</li>
<li>Manage parallel execution</li>
<li>Handle errors gracefully</li>
<li>Build final response</li></p>
<p><strong>Does NOT:</strong>
<li>Fetch data directly (delegates to services)</li>
<li>Apply business rules (delegates to calculation)</li>
<li>Match data (delegates to matcher)</li></p>
<p><strong>Think of it as:</strong> Project manager who delegates to specialists</p>
<p>---</p>
<p><h3>Benefit Service: The Policy Reader</h3></p>
<p><strong>Responsibilities:</strong>
<li>Communicate with external Benefit API</li>
<li>Manage OAuth authentication</li>
<li>Handle token refresh</li>
<li>Parse benefit responses</li>
<li>Convert API data to domain objects</li></p>
<p><strong>Does NOT:</strong>
<li>Make calculation decisions</li>
<li>Match with accumulators</li>
<li>Determine which benefits apply</li></p>
<p><strong>Think of it as:</strong> Librarian who fetches insurance policy details</p>
<p>---</p>
<p><h3>Accumulator Service: The Accountant</h3></p>
<p><strong>Responsibilities:</strong>
<li>Communicate with external Accumulator API</li>
<li>Manage OAuth authentication</li>
<li>Retrieve current spend amounts</li>
<li>Parse accumulator responses</li>
<li>Support both JSON and XML formats</li></p>
<p><strong>Does NOT:</strong>
<li>Apply accumulators to calculations</li>
<li>Match with benefits</li>
<li>Determine which accumulators to use</li></p>
<p><strong>Think of it as:</strong> Accountant who tracks what's been spent</p>
<p>---</p>
<p><h3>Benefit-Accumulator Matcher: The Integrator</h3></p>
<p><strong>Responsibilities:</strong>
<li>Filter benefits by provider characteristics</li>
<li>Match benefits with appropriate accumulators</li>
<li>Create SelectedBenefit objects with complete data</li>
<li>Handle multiple tiers and network types</li></p>
<p><strong>Does NOT:</strong>
<li>Fetch data (receives as input)</li>
<li>Calculate costs (creates data for calculation)</li>
<li>Communicate with external systems</li></p>
<p><strong>Think of it as:</strong> Data analyst who combines information</p>
<p>---</p>
<p><h3>Calculation Service: The Calculator</h3></p>
<p><strong>Responsibilities:</strong>
<li>Create and manage handler chain</li>
<li>Process benefits through business rules</li>
<li>Handle complex branching scenarios</li>
<li>Find highest member pay</li>
<li>Return complete calculation context</li></p>
<p><strong>Does NOT:</strong>
<li>Fetch data (receives as input)</li>
<li>Match data (receives matched data)</li>
<li>Make API calls</li></p>
<p><strong>Think of it as:</strong> Calculator that applies all the rules</p>
<p>---</p>
<p><h2>12. Integration Points</h2></p>
<p><h3>Integration Point 1: Cost Estimation → Repository</h3></p>
<p><pre><code class="language-python"><h1>Cost Estimation Service calls</h1>
rate = await self.repository.get_rate(rate_criteria)</p>
<p><h1>Repository returns</h1>
NegotiatedRate(
    rate=1000.00,
    rateType="AMOUNT",
    isRateFound=True
)</code></pre></p>
<p><strong>Contract:</strong> Repository provides negotiated rates from database</p>
<p>---</p>
<p><h3>Integration Point 2: Cost Estimation → Benefit Service</h3></p>
<p><pre><code class="language-python"><h1>Cost Estimation Service calls</h1>
benefit = await self.benefit_service.get_benefit(
    benefit_request,
    raise_exception=False
)</p>
<p><h1>Benefit Service returns</h1>
BenefitApiResponse(...)
<h1>OR</h1>
BenefitsNotFoundException(...)</code></pre></p>
<p><strong>Contract:</strong> Benefit Service provides coverage rules or exception</p>
<p>---</p>
<p><h3>Integration Point 3: Cost Estimation → Accumulator Service</h3></p>
<p><pre><code class="language-python"><h1>Cost Estimation Service calls</h1>
accumulator = await self.accumulator_service.get_accumulator(
    request,
    headers
)</p>
<p><h1>Accumulator Service returns</h1>
AccumulatorResponse(
    memberships={
        subscriber={
            accumulators=[...]
        }
    }
)</code></pre></p>
<p><strong>Contract:</strong> Accumulator Service provides current spend amounts</p>
<p>---</p>
<p><h3>Integration Point 4: Cost Estimation → Matcher Service</h3></p>
<p><pre><code class="language-python"><h1>Cost Estimation Service calls</h1>
selected_benefits = self.matcher_service.get_selected_benefits(
    membershipId,
    benefit_response,
    accumulator_response,
    provider,
    isOutofNetwork,
    pcp_specialty_codes
)</p>
<p><h1>Matcher Service returns</h1>
[SelectedBenefit(
    coverage=SelectedCoverage(
        matchedAccumulators=[...]
    )
)]</code></pre></p>
<p><strong>Contract:</strong> Matcher provides benefits with matched accumulators</p>
<p>---</p>
<p><h3>Integration Point 5: Cost Estimation → Calculation Service</h3></p>
<p><pre><code class="language-python"><h1>Cost Estimation Service calls</h1>
context = self.calculation_service.find_highest_member_pay(
    service_amount=1000.00,
    benefits=selected_benefits
)</p>
<p><h1>Calculation Service returns</h1>
InsuranceContext(
    member_pays=25.00,
    amount_copay=25.00,
    calculation_complete=True
)</code></pre></p>
<p><strong>Contract:</strong> Calculation Service provides final member cost</p>
<p>---</p>
<p><h2>13. Complete Flow Diagrams</h2></p>
<p><h3>High-Level Flow</h3></p>
<p><pre><code class="language-">┌──────────────┐
│ HTTP Request │
└──────┬───────┘
       ↓
┌────────────────────────────┐
│ Cost Estimation Service    │
│ ┌────────────────────────┐ │
│ │ Phase 1: Fetch         │ │
│ │ - Benefits (async)     │ │
│ │ - Accumulators (async) │ │
│ │ - Rates (async)        │ │
│ └────────────────────────┘ │
│         ↓                   │
│ ┌────────────────────────┐ │
│ │ Phase 2: Match         │ │
│ │ - Filter benefits      │ │
│ │ - Match accumulators   │ │
│ └────────────────────────┘ │
│         ↓                   │
│ ┌────────────────────────┐ │
│ │ Phase 3: Calculate     │ │
│ │ - Handler chain        │ │
│ │ - Apply business rules │ │
│ └────────────────────────┘ │
│         ↓                   │
│ ┌────────────────────────┐ │
│ │ Phase 4: Build Response│ │
│ └────────────────────────┘ │
└──────┬─────────────────────┘
       ↓
┌──────────────┐
│ HTTP Response│
└──────────────┘</code></pre></p>
<p><h3>Detailed Service Interaction</h3></p>
<p><pre><code class="language-">┌─────────────┐
│   Client    │
└──────┬──────┘
       │ HTTP POST
       ↓
┌──────────────────────────────────────────────────┐
│ Cost Estimation Service                          │
│                                                  │
│ asyncio.gather([                                 │
│   ┌──────────────┐  ┌──────────────┐  ┌───────┐│
│   │   Benefit    │  │ Accumulator  │  │ Rate  ││
│   │   Service    │  │   Service    │  │ Repo  ││
│   └──────┬───────┘  └──────┬───────┘  └───┬───┘│
│          │                  │              │    │
│          ↓ OAuth            ↓ OAuth        ↓ DB │
│   ┌──────────────┐  ┌──────────────┐  ┌───────┐│
│   │External API  │  │External API  │  │Spanner││
│   └──────────────┘  └──────────────┘  └───────┘│
│ ])                                               │
│          ↓                                       │
│ ┌──────────────────────────────────────────────┐│
│ │ Benefit-Accumulator Matcher                  ││
│ │ - Filter by provider                         ││
│ │ - Match accumulators                         ││
│ └──────────────────────────────────────────────┘│
│          ↓                                       │
│ ┌──────────────────────────────────────────────┐│
│ │ Calculation Service                          ││
│ │ - Handler chain (10 handlers)                ││
│ │ - Calculate member_pays                      ││
│ └──────────────────────────────────────────────┘│
└──────┬───────────────────────────────────────────┘
       │ JSON Response
       ↓
┌─────────────┐
│   Client    │
└─────────────┘</code></pre></p>
<p><h3>Data Flow Diagram</h3></p>
<p><pre><code class="language-">INPUT: CostEstimatorRequest
  ↓
[Cost Estimation Service]
  ↓
SPLIT: BenefitRequest[], RateCriteria[]
  ↓
PARALLEL FETCH:
  ├─ [Benefit Service] → BenefitApiResponse[]
  ├─ [Accumulator Service] → AccumulatorResponse
  └─ [Repository] → NegotiatedRate[]
  ↓
ORGANIZE: Dictionaries by provider hash
  ↓
PARALLEL PROCESS (per provider):
  ├─ [Matcher Service]
  │    Input: Benefit + Accumulator + Provider
  │    Output: SelectedBenefit[]
  ↓
  ├─ [Calculation Service]
  │    Input: Rate + SelectedBenefit[]
  │    Output: InsuranceContext
  ↓
BUILD: CostEstimateResponseInfo[]
  ↓
AGGREGATE: CostEstimatorResponse
  ↓
OUTPUT: JSON Response</code></pre></p>
<p>---</p>
<p><h2>14. Summary and Key Insights</h2></p>
<p><h3>The Five Services Working Together</h3></p>
<p><strong>The Orchestra Metaphor:</strong></p>
<p><pre><code class="language-">Cost Estimation Service = Conductor
  - Coordinates all musicians
  - Sets the tempo
  - Brings everything together</p>
<p>Benefit Service = First Violin
  - Provides melody (coverage rules)
  - Essential for the piece</p>
<p>Accumulator Service = Cello
  - Provides foundation (current state)
  - Supports the melody</p>
<p>Repository = Piano
  - Provides harmony (rates)
  - Completes the sound</p>
<p>Matcher Service = Arranger
  - Combines parts into coherent whole
  - Makes sure everything fits</p>
<p>Calculation Service = Composer
  - Applies the rules
  - Creates the final piece</code></pre></p>
<p><h3>Key Integration Points</h3></p>
<p><li><strong>Data Fetching</strong> (Async): Cost Estimation coordinates 3 parallel fetches</li>
<li><strong>Data Organization</strong> (Dictionaries): Fast provider-based lookups</li>
<li><strong>Data Matching</strong> (Matcher): Combines benefits with accumulators</li>
<li><strong>Business Logic</strong> (Calculation): Applies rules through handler chain</li>
<li><strong>Response Building</strong> (Aggregation): Combines all results</li></p>
<p><h3>Performance Benefits</h3></p>
<p><pre><code class="language-">Without parallelization: ~900ms
With parallelization: ~250ms
Speedup: 3.6x</p>
<p>Key optimizations:
  - Async parallel data fetching
  - Thread parallel provider processing
  - Dictionary O(1) lookups
  - Cached PCP codes</code></pre></p>
<p><h3>Error Handling Philosophy</h3></p>
<p><pre><code class="language-">Graceful Degradation:
  - One service fails → Others continue
  - One provider fails → Others processed
  - Return partial results when possible
  - Never crash entire request for one failure</code></pre></p>
<p><h3>Data Flow Summary</h3></p>
<p><pre><code class="language-">Request
  ↓ (Map)
Service Inputs
  ↓ (Fetch - Async)
Raw Data
  ↓ (Organize)
Dictionaries
  ↓ (Match)
SelectedBenefits
  ↓ (Calculate)
InsuranceContext
  ↓ (Build)
Response</code></pre></p>
<p><h3>Service Responsibilities Recap</h3></p>
<p>| Service | Primary Role | External Deps | Business Logic |
|---------|-------------|---------------|----------------|
| Cost Estimation | Orchestrator | All 4 services | Minimal (coordination) |
| Benefit | Data Fetcher | External API | None |
| Accumulator | Data Fetcher | External API | None |
| Matcher | Data Integrator | None | Medium (filtering/matching) |
| Calculation | Calculator | None | High (handler chain) |</p>
<p><h3>Best Practices Demonstrated</h3></p>
<p>✓ <strong>Separation of Concerns</strong>: Each service has one clear responsibility
✓ <strong>Dependency Injection</strong>: Loose coupling, easy testing
✓ <strong>Parallel Execution</strong>: Maximize performance
✓ <strong>Graceful Errors</strong>: System stays up despite failures
✓ <strong>Chain of Responsibility</strong>: Flexible business logic
✓ <strong>Async/Await</strong>: Non-blocking I/O
✓ <strong>Dictionary Lookups</strong>: Fast data access
✓ <strong>Type Hints</strong>: Clear contracts
✓ <strong>Logging</strong>: Comprehensive debugging</p>
<p>---</p>
<p><h2>Final Architecture Diagram</h2></p>
<p><pre><code class="language-">┌─────────────────────────────────────────────────────────────┐
│                    USER REQUEST                             │
│  "How much will I pay for this service?"                    │
└──────────────────────┬──────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────────────┐
│            COST ESTIMATION SERVICE (Orchestrator)           │
│            Lines: 201 | Role: Coordinate everything         │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ PHASE 1: PARALLEL DATA FETCH (Async)               │   │
│  │                                                     │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌────────────┐ │   │
│  │  │  BENEFIT    │  │ ACCUMULATOR │  │    RATE    │ │   │
│  │  │  SERVICE    │  │   SERVICE   │  │ REPOSITORY │ │   │
│  │  │  155 lines  │  │  180 lines  │  │  DB Query  │ │   │
│  │  │ External API│  │ External API│  │   Spanner  │ │   │
│  │  │             │  │             │  │            │ │   │
│  │  │ - Coverage  │  │ - Current   │  │ - Negotiat-│ │   │
│  │  │   rules     │  │   spend     │  │   ed rates │ │   │
│  │  │ - Copay     │  │ - Deduct.   │  │ - Rate type│ │   │
│  │  │ - Coins.    │  │   remaining │  │            │ │   │
│  │  │ - Network   │  │ - OOP Max   │  │            │ │   │
│  │  └─────────────┘  └─────────────┘  └────────────┘ │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ PHASE 2: DATA MATCHING                              │   │
│  │                                                     │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │ BENEFIT-ACCUMULATOR MATCHER SERVICE         │   │   │
│  │  │ 141 lines | Role: Combine & Filter          │   │   │
│  │  │                                             │   │   │
│  │  │ - Filter benefits by provider              │   │   │
│  │  │ - Match benefits with accumulators         │   │   │
│  │  │ - Create SelectedBenefit objects           │   │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ PHASE 3: CALCULATION                                │   │
│  │                                                     │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │ CALCULATION SERVICE                         │   │   │
│  │  │ 156 lines | Role: Apply business rules     │   │   │
│  │  │                                             │   │   │
│  │  │ Handler Chain (10 handlers):                │   │   │
│  │  │   ServiceCoverage → BenefitLimitation →    │   │   │
│  │  │   OOPMax → Deductible → CostShareCopay     │   │   │
│  │  │                                             │   │   │
│  │  │ Output: member_pays calculated              │   │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────┘   │
└──────────────────────┬──────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────────────┐
│                    RESPONSE TO USER                         │
│  "Member pays: $25 | Insurance pays: $975"                  │
└─────────────────────────────────────────────────────────────┘</code></pre></p>
<p>---</p>
<p><strong>End of Complete System Integration Guide</strong>
</p>
    </div>
    <div class="footer">
        <p><strong>Complete System Integration Guide</strong></p>
        <p>© 2025 | How Cost Estimation, Benefit, Accumulator, Matcher, and Calculation Services Work Together</p>
    </div>
</body>
</html>
